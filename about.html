<script type="module">
  import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

  // === SUPABASE (your project & anon key) ===
  const supabase = createClient(
    "https://rgxtvwnfqglsxnmvkkus.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJneHR2d25mcWdsc3hubXZra3VzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NjEwNzksImV4cCI6MjA4MDMzNzA3OX0.twtdhIMF4xnaBQsird8CyEb3g3Kh8bI5REChohdyGwo"
  );

  // === Canvas setup ===
  const canvas = document.getElementById('sketchCanvas');
  const ctx = canvas.getContext('2d');

  // Keep track of last devicePixelRatio used so we can reset scale cleanly
  let lastRatio = 1;

  function fitCanvasToDisplay() {
    // compute ratio and set backing store size (avoid repeated ctx.scale calls)
    const ratio = window.devicePixelRatio || 1;

    // Save current strokes as-is, then resize and redraw
    // Reset any transform so scale doesn't accumulate
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Set canvas internal pixel size for crisp rendering
    canvas.width = Math.floor(canvas.clientWidth * ratio);
    canvas.height = Math.floor(canvas.clientHeight * ratio);

    // Scale context to map CSS pixels -> backing pixels
    ctx.scale(ratio, ratio);

    // Apply common drawing defaults (line cap/join)
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    lastRatio = ratio;

    // redraw strokes at CSS coordinate space (strokes store CSS coords)
    redrawAll();
  }

  // ensure initial sizing after CSS applied
  requestAnimationFrame(fitCanvasToDisplay);
  window.addEventListener('resize', () => {
    // debounce a bit for smoother resizing on mobile
    clearTimeout(window._fitTimeout);
    window._fitTimeout = setTimeout(fitCanvasToDisplay, 80);
  });

  // drawing state
  let drawing = false;
  let erasing = false;
  let currentStroke = [];
  const strokes = []; // each stroke is an array of {x,y,erasing}

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches && e.touches[0];
    const clientX = touch ? touch.clientX : e.clientX;
    const clientY = touch ? touch.clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function start(e) {
    // pointer events/browsers may send right-clicks etc — only left-button or touch
    if (e.pointerType === 'mouse' && e.buttons && (e.buttons & 1) === 0) return;
    e.preventDefault();
    drawing = true;
    currentStroke = [];
    const p = getPos(e);
    currentStroke.push({ ...p, erasing });
    // capture pointer to continue receiving events even if pointer leaves canvas
    if (e.pointerId && canvas.setPointerCapture) {
      try { canvas.setPointerCapture(e.pointerId); } catch (err) { /* ignore */ }
    }
  }

  function move(e) {
    if (!drawing) return;
    e.preventDefault();
    const p = getPos(e);
    currentStroke.push({ ...p, erasing });

    // Draw the last segment(s) as they come in
    // If this is the first segment there will be two points (index 0 & 1)
    if (currentStroke.length >= 2) {
      const a = currentStroke[currentStroke.length - 2];
      const b = currentStroke[currentStroke.length - 1];
      ctx.beginPath();
      ctx.lineWidth = a.erasing ? 18 : 3;
      ctx.strokeStyle = a.erasing
        ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim()
        : '#000';
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    } else {
      // single-point fallback (draw a dot)
      const a = currentStroke[0];
      ctx.beginPath();
      ctx.lineWidth = a.erasing ? 18 : 3;
      ctx.strokeStyle = a.erasing
        ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim()
        : '#000';
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(a.x + 0.01, a.y + 0.01);
      ctx.stroke();
    }
  }

  function stop(e) {
    if (!drawing) return;
    drawing = false;
    if (currentStroke.length) strokes.push(currentStroke.slice());
    currentStroke = [];
    // release pointer capture
    if (e && e.pointerId && canvas.releasePointerCapture) {
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
    }
  }

  // pointer + touch binding (pointer handles mouse/touch/stylus in modern browsers)
  canvas.addEventListener('pointerdown', start);
  canvas.addEventListener('pointermove', move);
  window.addEventListener('pointerup', stop);

  // fallback for touch-only older browsers (passive:false to allow preventDefault)
  canvas.addEventListener('touchstart', start, { passive: false });
  canvas.addEventListener('touchmove', move, { passive: false });
  canvas.addEventListener('touchend', stop);

  function redrawAll() {
    // clear using CSS size (not backing store)
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

    for (const stroke of strokes) {
      if (!stroke || stroke.length < 1) continue;
      for (let i = 1; i < stroke.length; i += 1) {
        const a = stroke[i - 1], b = stroke[i];
        ctx.beginPath();
        ctx.lineWidth = a.erasing ? 18 : 3;
        ctx.strokeStyle = a.erasing
          ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim()
          : '#000';
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
      // If a stroke only had one point, draw a dot
      if (stroke.length === 1) {
        const a = stroke[0];
        ctx.beginPath();
        ctx.lineWidth = a.erasing ? 18 : 3;
        ctx.strokeStyle = a.erasing
          ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim()
          : '#000';
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(a.x + 0.01, a.y + 0.01);
        ctx.stroke();
      }
    }
  }

  // Tools
  document.getElementById('pencilBtn').addEventListener('click', () => { erasing = false; });
  document.getElementById('eraserBtn').addEventListener('click', () => { erasing = true; });
  document.getElementById('undoBtn').addEventListener('click', () => {
    strokes.pop();
    redrawAll();
  });
  document.getElementById('clearBtn').addEventListener('click', () => {
    strokes.length = 0;
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  });

  // friendly save messages (your list)
  const messages = [
    "That one is actually pretty!",
    "Artist appreciates this one ❤️",
    "Ahhh… try better maybe?",
    "World has never seen such an artist (please never draw again).",
    "The moon criticises this doodle.",
    "This doodle has strong 'why though?' energy.",
    "Beautiful. No one will understand it, ever.",
    "This belongs in a museum. A very small one.",
    "Even Yellow criticizes this one."
  ];
  function randomMsg() { return messages[Math.floor(Math.random() * messages.length)]; }

  // client-side bucket limit enforcement: delete oldest until under limit
  async function ensureBucketLimit(bucket = 'doodles', limitBytes = 50 * 1024 * 1024) {
    const { data: list, error } = await supabase.storage.from(bucket).list('', {
      limit: 1000,
      sortBy: { column: 'created_at', order: 'asc' }
    });
    if (error || !list) return;
    let total = list.reduce((s, f) => s + (f.size || 0), 0);
    while (total > limitBytes && list.length) {
      const oldest = list.shift();
      if (!oldest) break;
      await supabase.storage.from(bucket).remove([oldest.name]).catch(() => {});
      total -= (oldest.size || 0);
    }
  }

  // Export current canvas to blob (rasterize)
  async function saveCanvasToBlob() {
    // create an offscreen canvas sized to CSS width/height (no DPR scaling here)
    const out = document.createElement('canvas');
    out.width = canvas.clientWidth;
    out.height = canvas.clientHeight;
    const outCtx = out.getContext('2d');

    // background (paper)
    outCtx.fillStyle = (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim();
    outCtx.fillRect(0, 0, out.width, out.height);

    // draw current canvas contents (backing store -> scaled to CSS)
    outCtx.drawImage(canvas, 0, 0, out.width, out.height);

    return new Promise((resolve) => out.toBlob((b) => resolve(b), 'image/png', 0.95));
  }

  // Save button handler
  document.getElementById('saveDoodle').addEventListener('click', async () => {
    const status = document.getElementById('saveMsg');
    status.textContent = 'Saving…';

    await ensureBucketLimit('doodles', 50 * 1024 * 1024);

    const blob = await saveCanvasToBlob();
    if (!blob) {
      status.textContent = 'Could not create image!';
      return;
    }
    const filename = `doodle-${Date.now()}.png`;
    const { error } = await supabase.storage.from('doodles').upload(filename, blob, { upsert: false });

    if (error) {
      status.textContent = 'Error saving doodle!';
      alert('Error saving doodle — please try again.');
      console.error(error);
      return;
    }

    status.textContent = randomMsg();
    await loadDoodles();
  });

  // load doodles to grid
  async function loadDoodles() {
    const { data: files, error } = await supabase.storage.from('doodles').list('', {
      limit: 100,
      sortBy: { column: 'created_at', order: 'desc' }
    });
    if (error) {
      console.error('listing error', error);
      return;
    }
    const grid = document.getElementById('doodleGrid');
    if (!grid) return;
    grid.innerHTML = '';
    (files || []).forEach((f) => {
      const url = `https://rgxtvwnfqglsxnmvkkus.supabase.co/storage/v1/object/public/doodles/${encodeURIComponent(f.name)}`;
      const w = document.createElement('div');
      w.className = 'doodle-sticker';
      const img = document.createElement('img');
      img.src = url;
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'cover';
      img.alt = 'visitor doodle';
      w.appendChild(img);
      grid.appendChild(w);
    });
  }

  // initial load
  loadDoodles();
</script>
