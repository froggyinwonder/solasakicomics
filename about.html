<script>
/* Minimal, self-contained canvas/draw script — no imports, no Supabase.
   Drop it in by replacing your current <script> block. */

(function(){
  // DOM ready
  window.addEventListener('load', () => {
    const canvas = document.getElementById('sketchCanvas');
    const ctx = canvas.getContext('2d');
    const pencilBtn = document.getElementById('pencilBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const saveMsg = document.getElementById('saveMsg');

    // strokes stored in CSS coordinate space (x,y,erasing)
    let strokes = [];
    let currentStroke = [];
    let erasing = false;
    let drawing = false;

    function fitCanvas() {
      const ratio = window.devicePixelRatio || 1;
      // reset transform first to prevent accumulation
      ctx.setTransform(1,0,0,1,0,0);
      canvas.width = Math.floor(canvas.clientWidth * ratio);
      canvas.height = Math.floor(canvas.clientHeight * ratio);
      ctx.scale(ratio, ratio); // map CSS px -> backing px
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      redrawAll();
    }

    // initial fit
    fitCanvas();
    window.addEventListener('resize', () => {
      clearTimeout(window._fitT);
      window._fitT = setTimeout(fitCanvas, 80);
    });

    function posFromEvent(e){
      const r = canvas.getBoundingClientRect();
      const touch = e.touches && e.touches[0];
      const cx = touch ? touch.clientX : e.clientX;
      const cy = touch ? touch.clientY : e.clientY;
      return { x: cx - r.left, y: cy - r.top };
    }

    function startDraw(e){
      e.preventDefault();
      drawing = true;
      currentStroke = [];
      const p = posFromEvent(e);
      currentStroke.push({ x: p.x, y: p.y, erasing });
      // pointer capture if available
      if (e.pointerId && canvas.setPointerCapture) {
        try { canvas.setPointerCapture(e.pointerId); } catch(err) {}
      }
    }
    function moveDraw(e){
      if(!drawing) return;
      e.preventDefault();
      const p = posFromEvent(e);
      currentStroke.push({ x: p.x, y: p.y, erasing });
      // draw last segment
      if (currentStroke.length >= 2){
        const a = currentStroke[currentStroke.length-2];
        const b = currentStroke[currentStroke.length-1];
        ctx.beginPath();
        ctx.lineWidth = a.erasing ? 18 : 3;
        ctx.strokeStyle = a.erasing ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim() : '#000';
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      } else {
        // single point as dot
        const a = currentStroke[0];
        ctx.beginPath();
        ctx.lineWidth = a.erasing ? 18 : 3;
        ctx.strokeStyle = a.erasing ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim() : '#000';
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(a.x + 0.01, a.y + 0.01);
        ctx.stroke();
      }
    }
    function endDraw(e){
      if(!drawing) return;
      drawing = false;
      if (currentStroke.length) strokes.push(currentStroke.slice());
      currentStroke = [];
      if (e && e.pointerId && canvas.releasePointerCapture) {
        try { canvas.releasePointerCapture(e.pointerId); } catch(err) {}
      }
    }

    // pointer and touch
    canvas.addEventListener('pointerdown', startDraw);
    canvas.addEventListener('pointermove', moveDraw);
    window.addEventListener('pointerup', endDraw);
    canvas.addEventListener('touchstart', startDraw, { passive:false });
    canvas.addEventListener('touchmove', moveDraw, { passive:false });
    canvas.addEventListener('touchend', endDraw);

    function redrawAll(){
      ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
      for(const stroke of strokes){
        if (!stroke || stroke.length<1) continue;
        for(let i=1;i<stroke.length;i++){
          const a = stroke[i-1], b = stroke[i];
          ctx.beginPath();
          ctx.lineWidth = a.erasing ? 18 : 3;
          ctx.strokeStyle = a.erasing ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim() : '#000';
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
        if (stroke.length===1){
          const a = stroke[0];
          ctx.beginPath();
          ctx.lineWidth = a.erasing ? 18 : 3;
          ctx.strokeStyle = a.erasing ? (getComputedStyle(document.body).getPropertyValue('--paper') || '#fffdf7').trim() : '#000';
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(a.x+0.01, a.y+0.01);
          ctx.stroke();
        }
      }
    }

    // toolbar
    pencilBtn.addEventListener('click', ()=> { erasing=false; saveMsg.textContent='Using pencil'; });
    eraserBtn.addEventListener('click', ()=> { erasing=true; saveMsg.textContent='Using eraser'; });
    undoBtn.addEventListener('click', ()=> { strokes.pop(); redrawAll(); saveMsg.textContent='Undid last stroke'; });
    clearBtn.addEventListener('click', ()=> { strokes.length=0; redrawAll(); saveMsg.textContent='Cleared'; });

    // quick visual sanity — canvas ready
    saveMsg.textContent = 'Canvas ready — draw with finger or mouse.';

  }); // load
})();
</script>
